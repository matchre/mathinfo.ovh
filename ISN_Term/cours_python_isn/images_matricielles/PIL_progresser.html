<!DOCTYPE html>

<!-- Structure html/css/js de Nicolas Buyle-Bodin et Jean_Manuel Meny -->
<!-- "L'allègement" de MathJax a été réalisé par Mickael Bordonaro -->

<!-- Ces documents ont demandé plusieurs centaines d'heures de travail et de conception. -->
<!-- Ils sont sous licence Creative Commons BY-NC-SA : -->
<!-- Respect de la Paternité - Pas d'utilisation commerciale - Partage des conditions initiales à l'identique -->



<html lang="fr">

<!-- ***************************** En-tête du document ****************************** -->

<!-- Mirrored from www.mathinfo.ovh/ISN_Term/cours_python_isn/images_matricielles/PIL_progresser.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Sep 2019 14:56:55 GMT -->
<head>
	<meta charset="utf-8">
	<meta name="keywords" content="Lycée Lacassagne - Spécialité ISN en Terminale Scientifique"> 
	<meta name="designer" content="Nicolas Buyle-Bodin">
	<meta name="author"  content="Nicolas BUYLE-BODIN">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Titre de la page -->
	<link rel="shortcut icon" type="image/x-icon" href="../../images_index/icone_python.png" />
	<title> Langage Python en ISN </title>
	
	<!-- **************************************************************************** -->
	<!-- ************************** Feuilles de style CSS *************************** -->
	
	<!-- remise à zéro pour annuler style navigateur -->
	<link rel="stylesheet" href="../../../css/raz.css">
	
	<!-- prism permet la coloration syntaxique des programmes en Python -->
	<link rel="stylesheet" href="../../../css/prism.css"/>
		
	<!-- Coloration syntaxique avec codemirror -->
	<link rel="stylesheet" type="text/css" href="../../../codemirror/lib/codemirror.css">
    <link rel="stylesheet" type="text/css" href="../../../codemirror/theme/rubyblue.css">
    	
	<!-- Mise en page générale de la page -->
	<link rel="stylesheet" href="../../../css/Style_ISN_Terminale.css">
	
	<!-- ****************************** Fin d'appel CSS ***************************** -->
	<!-- **************************************************************************** -->


	<!-- **************************************************************************** -->
	<!-- ******************************* Scripts JS ********************************* -->
	<!-- JQuery - Nécessaire pour une partie des scripts ci-dessous. -->
	<script src="../../../scripts/jquery.js"></script>
	<script src="../../../scripts/jquery-iframe-auto-height-master/vendor/jquery.browser.js"></script>
    <script src="../../../scripts/jquery-iframe-auto-height-master/dist/jquery-iframe-auto-height.js"></script>
	
	<!-- Javascript du menu de navigation dans le site. -->
	<!-- Attention, dossier interne à la "capsule", à modifier pour chaque nouvelle capsule. -->
	<script src="../scripts_cours_python_isn/menu.js"></script>

	<!-- Javascript permettant la coloration syntaxique des programmes. -->
	<script src="../../../codemirror/lib/codemirror.js" type="text/javascript"></script>
    <script src="../../../codemirror/mode/python/python.js" type="text/javascript"></script>
	<script src="../../../codemirror/mode/xml/xml.js"></script>
	<script src="../../../codemirror/mode/javascript/javascript.js"></script>
	<script src="../../../codemirror/mode/css/css.js"></script>
	<script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
	<script src="../../../codemirror/addon/edit/matchbrackets.js"></script>
    
	<!-- Javascript permettant la coloration syntaxique des programmes. -->
	<script src="../../../scripts/prism.js"></script>  
    <script src="../../../scripts/clipboard.min.js"></script>
	
	<!-- Javascript d'utilisation de Skulpt (interpretation des programmes en Python. -->
	<script src="../../../skulpt/skulpt.min.js"></script>  
	<script src="../../../skulpt/skulpt-stdlib.js"></script>
	
	<!-- Javascript permettant d'exécuter les codes en Python. -->
	<!-- Nécessite Skulpt et CodeMirror. -->
	<script src="../../../scripts/prog_python.js"></script>
	
	<!-- Javascript permettant d'afficher e rendu des codes en Html/Css/JS. -->
	<!-- Nécessite CodeMirror. -->
	<script src="../../../scripts/prog_html.js"></script>
	 
    <!-- Javascript permettant d'utiliser Mathjax. -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        showProcessingMessages: false,
        showMathMenu: false,
        showMathMenuMSIE: false,
        jax: ["input/TeX","output/SVG"],
        tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] }
        });
    </script>
    <script type="text/javascript" src="../../../mathjax/MathJax8480.js?config=TeX-AMS_SVG-full&amp;locale=fr"></script>
    	 
	<!-- Javascript permettant l'affichage des boîtes à onglets. -->
	<script src="../../../scripts/boite_onglet.js"></script>
	 
	<!-- Javascript permettant l'affichage des "accordéons solutions pour les exercices HTML/CSS". -->
	<script src="../../../scripts/accordeon.js"></script>
	
	<!-- ****************************** Fin d'appel JS ****************************** -->
	<!-- **************************************************************************** -->


</head>



<!-- ************************* Corps principal du document ************************** -->
<body>

	<!-- **************************************************************************** -->
	<!-- *********** Encart gauche : menu de navigation dans le(s) site(s) ********** -->
	<aside id="navparagraphe">  
		<ul id="menu_accordeon">
			
		</ul>
	</aside>
	<!-- ************************* Fin de l'encart gauche *************************** -->
	<!-- **************************************************************************** -->


	<!-- **************************************************************************** -->
	<!-- ********** Encart droit : menu de navigation d'une page à l'autre ********** -->
	<div id="menu_droit">  
		<a href="#" title="Haut de page"><div id="haut"></div></a>
		<a href="#" title="Page précédente"><div id="precedent"></div></a>
		<a href="#" title="Page suivante"><div id="suivant"></div></a>
		<a href="#" title="Accueil principal"><div id="retour_accueil"></div></a>
	</div>
	<!-- ************************* Fin de l'encart gauche *************************** -->
	<!-- **************************************************************************** -->


	<!-- **************************************************************************** -->
	<!-- ************************** Bannière de la page ***************************** -->
	<header>
		<div id="entete">
			<h1><span class="majuscules">Python</span></h1>
			<p>
				Module PIL<br>
				Exercices pour progresser
			</p>
		</div>
	</header>
	<!-- *************************** Fin de la bannière ***************************** -->
	<!-- **************************************************************************** -->
	

	<!-- **************************************************************************** -->
	<!-- ***************************** Corps de la page ***************************** -->
	<div id="corps">

    <!-- **************************************************************************** -->
    <!-- ************** Fil d'Ariane pour repérer la page dans le site ************** -->
    <ul id="ariane">  

    </ul>
    <!-- ************************** Fin du fil d'Ariane ***************************** -->
    <!-- **************************************************************************** -->


	<!-- **************************************************************************** -->
	<!-- ********* Section principale : notions et exercices correspondants ********* -->
	<section>
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<article>
			<p>
				Dans les exercices de cette page, il n'y aura souvent pas de piste.
				Seules les solutions et d'éventuelles variantes seront proposées.<br>
				A vous de bien analyser la question posée ainsi que la démarche proposée
				afin de concevoir les programmes correspondants.
			</p>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->
		
		
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<h1 class="exercice">Négatif en couleurs</h1>
		<article>
			<p>
				Le programme à concevoir doit faire en sorte que l'image obtenue soit l'image
				d'origine en &laquo;négatif&raquo;, comme le présentent les deux images ci-dessous.
				L'image du logo <span class="majuscules">Python</span> est téléchargeable en cliquant
				dessus.
			</p>
			
			<table class="classique">
				<tr><th>Image d'origine au format <code>.png</code></th>
					<th>Négatif de l'image</th></tr>
				<tr><td style="width: 50%;"><a class="lien_image" href="images_a_telecharger/Logo_Python_Couleur.png" download="Logo_Python_Couleur.html">
												<img src="images_matricielles_images/Logo_Python_Couleur.png"/>
											</a></td>
					<td style="width: 50%;"><img src="images_matricielles_images/Logo_Python_Negatif.png"/></td></tr>
			</table>
			
			<div class="boite_onglets">
				<ul class="onglets">
					<li class="onglet">Une solution ?</li>
				</ul>
				<div class="zone_boite">   
					<div class="contenu">
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image                             # Ne pas oublier de l'importer pour un programme indépendant

##----- Informations sur l'image d'origine -----##
im = Image.open('Logo_Python_Couleur.png')
couleur = im.mode
l, h = im.size

##----- Conception de la nouvelle image -----##
im_nega = Image.new(couleur, (l, h))              # Symetrie horizontale

for x in range(l):
    for y in range(h):                            # On parcourt chaque pixel de l'image analysée plus haut
        r, v, b = im.getpixel((x, y))             # On récupère le triplet de couleur
        
        im_nega.putpixel((x, y), (255-r, 255-v, 255-b))

im_nega.save('Logo_Python_Negatif.png')
im_nega.show()</code></pre>
					</div> <!-- Fin contenu -->
				</div>
			</div>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->
		
		
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<h1 class="exercice">Mise en relief</h1>
		<article>
			<img class="img_flotte" src="images_matricielles_images/Voisins.png">
			<p>
				Dans une image matricielle, chaque pixel a, au maximum, huit voisins. On a représenté
				ci-contre le pixel de coordonnées <code>(x, y)</code> avec ses voisins.
			</p>
			<p>
				A partir d'une image en nuances de gris (<em>au format
				<code class="language-python">'L'</code> du module <code>PIL</code>, c'est-à-dire
				que la nuance de chaque pixel est définie par un unique entier compris entre
				<code class="language-python">0</code> et <code class="language-python">255</code>.</em>),
				programmer l'algorithme ci-dessous afin d'obtenir une &laquo;mise en relief&raquo;
				de cette image :
			</p>
			<ul class="enum">
				<li>On considère un pixel de coordonnées <code>(x, y)</code> et de niveau de gris
					<code>g</code>.</li>
				<li>On calcule la nouvelle valeur de <code>g</code> à partir des niveaux de gris des
					pixels voisins : <code>g = 128 + (-2*m-n-p+q+s+2*t) // 8</code>.<br>
					<em>On pourra définir une fonction <code class="language-python">voisins()</code>
					qui renvoie la liste des coordonnées des pixels voisins du pixel de coordonnées
					<code>(x, y)</code></em>.</li>
			</ul>
			<p>
				Question supplémentaire : justifier que cette nouvelle valeur de <code>g</code>
				est bien comprise entre <code class="language-python">0</code> et
				<code class="language-python">255</code>.</li>
			</p>
			
			<table class="classique">
				<tr><th>Image d'origine</th>
					<th>Image en relief</th></tr>
				<tr><td style="width: 50%;"><a class="lien_image" href="images_a_telecharger/Ban_Lac_Grise.jpg" download="Ban_Lac_Grise.html">
												<img src="images_matricielles_images/Ban_Lac_Grise.jpg"/>
											</a></td>
					<td style="width: 50%;"><img src="images_matricielles_images/Ban_Lac_Relief.jpg"/></td></tr>
			</table>
			
			<div class="boite_onglets">
				<ul class="onglets">
					<li class="onglet">Une piste</li>
					<li class="onglet">La fonction <code>voisines()</code></li>
					<li class="onglet">Une solution</li>
					<li class="onglet">Une variante</li>
				</ul>
				<div class="zone_boite">   
					<div class="contenu">
						Je suis gentil, voici une petite piste :<br>
						on pourra commencer par transformer l'image d'origine en lui ajoutant des
						&laquo;bords noirs&raquo; de <code class="language-python">1</code> pixel
						d'épaisseur pour avoir une fonction <code class="language-python">voisines()</code>
						plus facile à définir...
					</div> <!-- Fin contenu -->
					
					<div class="contenu">
						<p>
							Première fonction possible : on a encadré l'image de bords noirs donc
							chaque pixel de l'image d'origine a huit voisins.
						</p>
						<div class="entoure_python">
							<pre class="line-numbers"><code class="language-python">
def voisines(x, y, l, h):
    """ Entrees : x et y sont les coordonnées d'un pixel situé dans une image de largeur l et de hauteur h
		Sorties : Renvoie la liste des coordonnées des pixels voisins de ce pixel."""
    liste = [(x-1, y-1),                            # On considère que chaque pixel a 8 voisins
             (x-1, y),
             (x-1, y+1),
             (x, y-1),
             (x, y+1),
             (x+1, y-1),
             (x+1, y),
             (x+1, y+1)]
	return liste</code></pre>
						</div>

						<p>
							Seconde fonction possible : on gère les pixels situés au bord et/ou
							dans les &laquo;coins&raquo; de l'image.
						</p>
						<div class="entoure_python">
							<pre class="line-numbers"><code class="language-python">
def voisines(x, y, l, h):
    """ Entrees : x et y sont les coordonnées d'un pixel situé dans une image de largeur l et de hauteur h
		Sorties : Renvoie la liste des coordonnées des pixels voisins de ce pixel."""
    liste = [(x-1, y-1),                            # On considère que chaque pixel a 8 voisins
             (x-1, y),
             (x-1, y+1),
             (x, y-1),
             (x, y+1),
             (x+1, y-1),
             (x+1, y),
             (x+1, y+1)]

	for coor in reversed(liste):                    # On parcourt la liste renversée
        if coor[0]<0 or coor[0]>l-1 or coor[1]<0 or coor[1]>h-1:
            liste.remove(coor)                      # Lorsque les coordonnées sont hors-domaine, on les enlève de la liste
                                                    # (raison pour laquelle il faut parcourir la liste renversée)
    return liste</code></pre>
						</div>
					</div> <!-- Fin contenu -->
					
					<div class="contenu">
						<p>
							Avec la première fonction <code class="language-python">voisines()</code>
							et la création d'une image comportant des bords :
						</p>
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image

##----- Définition des Fonctions -----##
def voisines(x, y, l, h):
    """ Entrees : x et y sont les coordonnées d'un pixel situé dans une image de largeur l et de hauteur h
        Sorties : Renvoie la liste des coordonnées des pixels voisins de ce pixel."""
    liste = [(x-1, y-1),                            # On considère que chaque pixel a 8 voisins
             (x-1, y),
             (x-1, y+1),
             (x, y-1),
             (x, y+1),
             (x+1, y-1),
             (x+1, y),
             (x+1, y+1)]
    return liste


def compo(im, liste):
    """ Entrees : im est une image, liste contient les coordonnées des voisins d'un pixel
        Sorties : Renvoie la composante grise du pixel calculée à partir des composantes
            de ses 6 voisines m, n, p, q, s et t dont les coordonnées se trouvent aux indices
            0, 1, 3, 4, 6, 7 dans la liste."""
    for i in range(8):
        liste[i] = int(im.getpixel(liste[i]))
    return 128 + (-2*liste[0]-liste[1]-liste[3]+liste[4]+liste[6]+2*liste[7])


##----- Informations sur l'image d'origine -----##
im = Image.open('Ban_Lac_Grise.jpg')
l, h = im.size

##----- Ajout de bords à cette image -----##
im_grande = Image.new('L', (l+2, h+2))
                                            
for x in range(l+2):
    for y in range(h+2):
        if x==0 or y==0 or x==l+1 or y==h+1:
            im_grande.putpixel((x,y), 0) 
        else:
            im_grande.putpixel((x,y), im.getpixel((x-1, y-1)))

im_grande.save('Ban_Lac_Bords.jpg')
im_grande.show()
                                         

##----- Conception de la nouvelle image -----##
im_grande = Image.open('Ban_Lac_Bords.jpg')
im_relief = Image.new('L', (l, h))
                                            
for x in range(l):
    for y in range(h):
        im_relief.putpixel((x,y), compo (im_grande, voisines(x+1, y+1, l, h))) 
                                         

##-----Finalisation-----##
im_relief.save('Ban_Lac_Relief.jpg')
im_relief.show()</code></pre>
					</div> <!-- Fin contenu -->
					
					<div class="contenu">
						<p>
							Avec la seconde fonction <code class="language-python">voisines()</code>,
							davantage modifiée :
						</p>
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image

##----- Définition des Fonctions -----##
def voisines(im, x, y, l, h):
    """ Entrees : x et y sont les coordonnées d'un pixel situé dans l'image im de largeur l et de hauteur h
        Sorties : Renvoie la liste des coordonnées des pixels voisins de ce pixel."""
    liste = [(x-1, y-1),                            # On considère les 6 voisins "intéressants"
             (x-1, y),
             (x, y-1),
             (x, y+1),
             (x+1, y),
             (x+1, y+1)]
    s = []                                          # Liste des composantes actualisées m, n, p, q, s et t
             
    for coor in liste:
        if coor[0]<0 or coor[0]>l-1 or coor[1]<0 or coor[1]>h-1:
            s.append(255)                           # Si le pixel est "hors cadre", on lui attribue la couleur blanc
        else:
            s.append(im.getpixel(coor))             # Sinon on ajoute sa composante
    
    g = 128 + (-2*s[0]-s[1]-s[2]+s[3]+s[4]+2*s[5])
    return g


##----- Informations sur l'image d'origine -----##
im = Image.open('Ban_Lac_Grise.jpg')
l, h = im.size

##----- Conception de la nouvelle image -----##
im_relief = Image.new('L', (l, h))
                                            
for x in range(l):
    for y in range(h):
        im_relief.putpixel((x,y), voisines(im, x, y, l, h)) 
                                         

##-----Finalisation-----##
im_relief.save('Ban_Lac_Relief.jpg')
im_relief.show()</code></pre>
					</div> <!-- Fin contenu -->
				</div>
			</div>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->
		
		
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<h1 class="exercice">Algorithme de seuil</h1>
		<article>
			<img class="img_flotte" src="images_matricielles_images/Voisins.png">
			<p>
				Pour localiser différents objets dans une image, il est nécessaire de réussir à
				localiser les contours de ces objets. Généralement, les nuances des pixels voisins
				seront très différentes les unes des autres. 
			</p>
			<p>
				Pour cela, on peut appliquer un <strong>algorithme de distance 1</strong> (<em>au sens
				de &laquo;distance dans un repère orthonormé&raquo;</em>) qui va calculer pour le pixel de
				coordonnées <code>(x, y)</code> la distance entre les niveaux de gris de ses voisins :
				\(d = \sqrt{\left(n-s\right)^2+\left(p-q \right)^2}\).
			</p>
			<p>
				En comparant cette distance à un certain seuil (<em>à définir, ci-dessous, la valeur 25
				a été choisie</em>), le pixel de coordonnées <code>(x, y)</code> sera affiché soit en noir,
				soit en blanc. Appliquer le programme ainsi conçu au logo <span class="majuscules">Python</span>
				définit en nuances de gris.
			</p>
			
			<table class="classique">
				<tr><th>Image d'origine</th>
					<th>Image en relief</th></tr>
				<tr><td style="width: 50%;"><a class="lien_image" href="images_a_telecharger/Logo_Python_gris.png" download="Logo_Python_gris.html">
												<img src="images_matricielles_images/Logo_Python_gris.png"/>
											</a></td>
					<td style="width: 50%;"><img src="images_matricielles_images/Logo_Python_detoure.png"/></td></tr>
			</table>
			
			<div class="boite_onglets">
				<ul class="onglets">
					<li class="onglet">Racine carrée</li>
					<li class="onglet">Une solution</li>
				</ul>
				<div class="zone_boite">   
					<div class="contenu">
						<p>
							On importe la racine carrée avec le module <code>math</code> :
						</p>
						<div class="entoure_python">
							<pre class="line-numbers"><code class="language-python">
from math import sqrt</code></pre>
						</div>
						<p>
							Pour le reste, c'est quasi-identique à la mise en relief.
						</p>
					</div> <!-- Fin contenu -->
					
					<div class="contenu">
						<p>
							Attention, l'image d'origine est en mode couleur <code>'L'</code>,
							qui définit une image en nuances de gris.
						</p>
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image
from math import sqrt

##----- Définition des Fonctions -----##
def ecart(im, x, y, l, h):
    """ Entrees : x et y sont les coordonnées d'un pixel situé dans une image de largeur l et de hauteur h
		Sorties : calcule les variations de niveau de gris autour (distance 1) de ce pixel"""
    liste = [(x, y-1),                  		# On considère les 4 voisins "intéressants"
             (x, y+1),
             (x-1, y),
             (x+1, y)]
    compo = []                         		 	# Liste des composantes actualisées n, s, p et q
             
    for coor in liste:
        if coor[0]<0 or coor[0]>l-1 or coor[1]<0 or coor[1]>h-1:
            compo.append(255)               	# Si le pixel est "hors cadre", on lui attribue la couleur blanc
        else:
            compo.append(im.getpixel(coor)) 	# Sinon on ajoute sa composante
    
    d = int(sqrt((compo[0]-compo[1])**2+(compo[2]-compo[3])**2))
    return d

##----- Informations sur l'image d'origine -----##
im = Image.open('Logo_Python_gris.png')
l, h = im.size

##----- Conception de la nouvelle image -----##
seuil = 25                              # Seuil de "détourage"
im_detour = Image.new('L', (l, h))
                                            
for x in range(l):
    for y in range(h):
        if ecart(im, x, y, l, h) < seuil:
            im_detour.putpixel((x,y), 255)
        else:
            im_detour.putpixel((x,y), 0)
                                         

##-----Finalisation-----##
im_detour.save('Logo_Python_detoure.html')
im_detour.show()</code></pre>
					</div> <!-- Fin contenu -->
				</div>
			</div>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->
		
		
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<h1 class="exercice">Palette de couleurs</h1>
		<article>
			<img class="img_flotte" src="images_matricielles_images/Couplages_RVB_02.png">
			<p>
				 On souhaite afficher la palette de toutes les couleurs possibles (<em>certaines en
				 double</em>) au format RGB (<em>ci-contre, sans les textes</em>).
			</p>
			
			<ol class="liste_num">
				<li>Quelles sont les dimensions, en pixels, de cette figure ?</li>
				<li>On s'intéresse au rectangle Jaune-Cyan-Bleu-Rouge.<br>
					Exprimer les composantes R, G et B d'un pixel en fonction de son
					abscisse x et de sa colonne y.</li>
				<li>Exprimer de la même manière les composantes R, G et B d'un pixel du
					second rectangle en fonction de son abscisse x et de sa colonne y.</li>
				<li>En déduire le programme permettant d'afficher cette palette de couleur.</li>
			</ol>
			
			<div class="boite_onglets">
				<ul class="onglets">
					<li class="onglet">Une solution ?</li>
				</ul>
				<div class="zone_boite">   
					<div class="contenu">
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image                               # Ne pas oublier de l'importer pour un programme indépendant

##----- Informations sur l'image -----##
largeur = 511                                       # largeur de l'image, en pixels
hauteur = 511                                       # hauteur de l'image, en pixels
couleur = 'RGB'

##----- Conception de la nouvelle image -----##
im = Image.new(couleur, (largeur, hauteur))

for x in range(largeur):
	# La figure est divisée en quatre carrés
	# Première moitié des abscisses
    if x < 256:
        r = 255-x
        b = 0
	
	# Seconde moitié des abscisses
    else:
        r = 0
        b = x-255
    for y in range(hauteur):
		# Le carré "blanc"
        if x < 256 and y > 255:
            r, v, b = 255, 255, 255
		# Première moitié des ordonnées
        elif y < 256:
            v = 255-y
		# Seconde moitié des ordonnées
        else:
            v = 0
            r = y-255
        im.putpixel((x, y), (r, v, b))

im.save('Palette.html')
im.show()</code></pre>
					</div> <!-- Fin contenu -->
				</div>
			</div>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->
		
		
	
		<!-- ************************************************************************ -->
		<!-- ************* Une partie : un titre h1 suivi d'un article ************** -->
		<h1 class="exercice">Compresser une image</h1>
		<article>
			<a class="lien_image" href="images_a_telecharger/Ban_Lacassagne.jpg" download="Ban_Lacassagne.html">
				<img class="img_centre" src="images_matricielles_images/Ban_Lacassagne.jpg"/></a>
			
			<p>
				L'image originale <code>Ban_Lacassagne.jpg</code> est trop grande pour être utilisée
				en vraie grandeur dans certains des exercices précédents. Elle a été compressée
				(<em>réduite</em>) de manière automatique par le logiciel d'affichage (<em>ici le
				navigateur</em>). 
			</p>
			<p>
				Le but de cet exercice est de programmer une compression de l'image en suivant
				l'algorithme ci-dessous : 
			</p>
			
			<img src="images_matricielles_images/Compression.png" class="img_flotte" style="height: 150px;">
			<ol class="liste_num">
				<li>On note <code>k</code> le coefficient de réduction : la largeur et la hauteur
					de l'image seront divisées par <code>k</code> donc le nombre total de pixels
					sera divisé par <code>k²</code>.</li>
				<li>On «regroupe» les pixels par carrés de côtés <code>k</code>.<br>
					<em>Ci-contre, de côté <code>k = 2</code></em>.</li>
				<li>On remplace ces <code>k²</code> pixels par un unique pixel dont les composantes
					<code>(r, v, b)</code> sont les moyennes des composantes des <code>k²</code>
					pixels de l'image d'origine.</li>
			</ol>
			
			<div class="boite_onglets">
				<ul class="onglets">
					<li class="onglet">Une solution</li>
					<li class="onglet">Une variante</li>
				</ul>
				<div class="zone_boite">   
					<div class="contenu">
						<p>
							On a appliqué le coefficient de réduction <code>k = 4</code> :
						</p>
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image
                     
##----- Coefficient de Réduction -----##
k = 4

##----- Informations sur l'image d'origine -----##
im = Image.open('Ban_Lacassagne.jpg')
l, h = im.size

##----- Conception de la nouvelle image -----##
largeur, hauteur = l//k, h//k                               # Nouvelles dimensions
im_red = Image.new('RGB', (largeur, hauteur))               # Image "compressée"

for x in range(0, largeur*k, k):                            # Saut de k en k en largeur
    for y in range(0, hauteur*k, k):                        # Saut de k en k en hauteur
        rouge, vert, bleu = 0, 0, 0                         # Somme des composantes des k² pixels
        for i in range(k):
            for j in range(k):
                r, v, b = im.getpixel((x+i, y+j))
                rouge += r
                vert += v
                bleu += b
        
        rouge = rouge//(k*k)                                # On divise les sommes par le nombre de pixels (moyennne)
        vert = vert//(k*k)
        bleu = bleu//(k*k)
        
        # On place le pixel dans l'image réduite (attention aux coordonnées...)
        im_red.putpixel((x//k, y//k), (rouge, vert, bleu))
                                         

##-----Finalisation-----##
im_red.save('Ban_Lac_Reduit.jpg')                           # Sauvegarde
im_red.show()                                               # Affichage</code></pre>
					</div> <!-- Fin contenu -->
					   
					<div class="contenu">
						<p>
							Le programme précédent &laquo;détruit&raquo; dans l'image les lignes en bas
							et les colonnes à droite qui sont en trop (<em>illustrées en rouge dans la
							figure ci-dessus</em>). Avec un peu d'arithmétique, on
							peut &laquo;harmoniser&raquo; cette destruction entre les lignes du haut et
							du bas ainsi qu'entre les colonnes de gauche et de droite :
						</p>
						<pre class="line-numbers"><code class="language-python">
##----- Importation des Modules -----##
from PIL import Image

##----- Définition des Fonctions -----##
def moy(im, x, y, k):
	""" Entrees : im est une image, x et y sont les coordonées du pixel étudié, k est le coef de réduction
		Sorties : Renvoie le nouveu triplet de composantes (r, v, b) du pixel de coordonnées (x, y).
			Ces composantes sont la moyenne des composantes d'un carré de pixels de côté k."""
    rouge, vert, bleu = 0, 0, 0                             # Somme des composantes des k² pixels
    for i in range(k):
        for j in range(k):
            r, v, b = im.getpixel((x+i, y+j))
            rouge += r
            vert += v
            bleu += b
        
    rouge = rouge//(k*k)                                    # On divise les sommes par le nombre de pixels (moyennne)
    vert = vert//(k*k)
    bleu = bleu//(k*k)
    return (rouge, vert, bleu)

##----- Coefficient de Réduction -----##
k = 4

##----- Informations sur l'image d'origine -----##
im = Image.open('Ban_Lacassagne.jpg')
l, h = im.size

##----- Conception de la nouvelle image -----##
largeur, hauteur = l//k, h//k                               # Nouvelles dimensions
im_red = Image.new('RGB', (largeur, hauteur))               # Image "compressée"

espace_l = (l-k*largeur)//2                                 # nombre de pixels à enlever à gauche des lignes
espace_c = (h-k*hauteur)//2                                 # nombre de pixels à enlever en haut des colonnes

for x in range(espace_l, espace_l+largeur*k, k):            # Saut de k en k en largeur
    for y in range(espace_c, espace_c+hauteur*k, k):        # Saut de k en k en hauteur
                
        # On place le pixel dans l'image réduite (attention aux coordonnées...)
        im_red.putpixel((x//k, y//k), moy(im, x, y, k))

##-----Finalisation-----##
im_red.save('Ban_Lac_Reduit2.jpg')                          # Sauvegarde
im_red.show()                                               # Affichage</code></pre>
					</div> <!-- Fin contenu -->
				</div>
			</div>
			
		</article>
		<!-- *************************** Fin de la partie *************************** -->
		<!-- ************************************************************************ -->

		
		
		
		
		
		
		

		<!-- fin de l'énoncé -->
	</section>
	<!-- fin de l'encart droit -->
	
	</div>
	<!-- fin du corps de la page -->

	<!-- début du pied de page -->
	<footer> 
		<span id="a_gauche">N. Buyle-Bodin</span>
		<span id="a_droite"> </span>
	</footer>
	
</body>

<!-- Mirrored from www.mathinfo.ovh/ISN_Term/cours_python_isn/images_matricielles/PIL_progresser.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Sep 2019 14:57:22 GMT -->
</html>
